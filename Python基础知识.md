### 1、python垃圾回收机制GC

引用计数机制为主，标记-清除、隔代回收两种机制为辅的策略

  ##### （1）计数机制
  
  每一个对象有一个引用计数器，当计数器为0时，说明此对象没有被使用了，将其内存销毁
  
  优点：实时性高，一旦为0，立刻销毁
  
  缺点：为了维护引用计数器，消耗额外资源；无法处理循环引用的问题，循环引用会导致内存泄漏
    
  ##### （2）标记-清除（在 ↑ 的基础上）
  
  关注可能会产生循环引用的对象，如list，tuple，dict（容器对象）
  
  GC会把所有活动对象打上标记，可以看做点，引用关系构成边，即成为有向图
  
  从根对象root出发，沿着有向边出发，遍历不到的和存在环的就是需要清除的
  

  ##### （3）隔代回收（在 ↑ 的基础上）
  
  以空间换时间
  
  根据内存中对象的存活时间将其分为3代，新生对象放到0代，如果从0代垃圾回收活下来，变成1代，如此循环直到2代
  

### 2、进程、线程（底层）


Python并发编程：串行 → 并行，提升执行效率

最终是线程在工作，多个线程组成一个进程，py文件运行时候，创建一个进程（主进程），进程创建一个线程（主线程）

##### （1）线程

    计算机中，能被 CPU 调度的最小单元
    
    ```
    import threading  # 多线程库

    t=threading.Thread(target=函数名，args=(11,22,33))  # 其中，后面几个数字是函数的参数
    t.start（） # 让线程开始工作

    ```

    
##### （2）进程（资源消耗比较多）

    计算机资源分配的最小单元，为线程提供资源的单位
    
    ```
    import multiprocessing  # 多进程包
    
    t=multiprocessing.Process(target=函数名，args=(11,22,33))
    t.start()
    
    ```
##### （3）GIL锁（全局解释器锁）

    保证一个进程中同一时刻只有一个线程可以被GPU调用
    
    所以在多核CPU的计算机下，在GIL锁下，则需要变成多进程并发，才能高并发
    
    高I/O的请求：不太需要CPU，可以多线程
    
    高计算的请求：需要CPU，且因为有GIL锁，用多进程
    
 ##### （4）线程安全
 
    多个线程同时操作一个东西时候，可能会产生线程不安全，因为线程同步运行
    
    （官方一点解释：处理数据有概率有交集 ↑ ）
    
    解决方法：手动加锁（线程锁）（加在函数里面）
    
    细节：这几个线程要用同一把锁才行，一把锁一个时间只会有一个线程在用
    
    
    有些数据类型是线程安全的（本身自带锁）：list类型.....
    
    
### 3、线程锁（常见两种）

##### （1）Lock 同步锁

    不支持锁的嵌套，一嵌套：死锁

##### （2） RLock 递归锁

    这个支持，其他的和 Lock 一样
    
### 4、线程池

线程开太多了，反而可能性能下降（线程之间的上下文切换）

解决方法：用线程池

from concurrent.futures import ThreadPoolExecutor

pool=ThreadPoolExecutor（100）

pool.submit(函数名，参数1，参数2.........)  # 由线程池来安排给这个任务的线程




#### 5、死锁

https://blog.csdn.net/shanniuliqingming/article/details/120926413?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165720147516780357217689%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165720147516780357217689&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120926413-null-null.142^v32^down_rank,185^v2^control&utm_term=Python%20threading&spm=1018.2226.3001.4187

Lock嵌套了：死锁

线程互相竞争多把锁（一个线程握了一个其他线程需要的锁）：死锁



#### byte数据结构

#### 深拷贝、浅拷贝

#### 装饰器

#### pytorch优化器区别

#### python的一些自动化框架包
