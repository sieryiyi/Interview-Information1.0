#### 1、python垃圾回收机制GC

引用计数机制为主，标记-清除、隔代回收两种机制为辅的策略

  ##### （1）计数机制
  
  每一个对象有一个引用计数器，当计数器为0时，说明此对象没有被使用了，将其内存销毁
  
  优点：实时性高，一旦为0，立刻销毁
  
  缺点：为了维护引用计数器，消耗额外资源；无法处理循环引用的问题，循环引用会导致内存泄漏
    
  ##### （2）标记-清除（在 ↑ 的基础上）
  
  关注可能会产生循环引用的对象，如list，tuple，dict（容器对象）
  
  GC会把所有活动对象打上标记，可以看做点，引用关系构成边，即成为有向图
  
  从根对象root出发，沿着有向边出发，遍历不到的和存在环的就是需要清除的
  

  ##### （3）隔代回收（在 ↑ 的基础上）
  
  以空间换时间
  
  根据内存中对象的存活时间将其分为3代，新生对象放到0代，如果从0代垃圾回收活下来，变成1代，如此循环直到2代
  

#### 进程、线程（底层）


Python并发编程：串行 → 并行，提升执行效率

最终是线程在工作，多个线程组成一个进程，py文件运行时候，创建一个进程（主进程），进程创建一个线程（主线程）

##### （1）线程

    计算机中，能被 CPU 调度的最小单元
    
    ```
    import threading  # 多线程库

    t=threading.Thread(target=函数名，args=(11,22,33))  # 其中，后面几个数字是函数的参数
    t.start（） # 让线程开始工作

    ```

    
##### （2）进程（资源消耗比较多）

    计算机资源分配的最小单元，为线程提供资源的单位
    
    ```
    import multiprocessing  # 多进程包
    
    t=multiprocessing.Process(target=函数名，args=(11,22,33))
    t.start()
    
    ```
    
    

    







#### 死锁

https://blog.csdn.net/shanniuliqingming/article/details/120926413?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165720147516780357217689%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165720147516780357217689&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120926413-null-null.142^v32^down_rank,185^v2^control&utm_term=Python%20threading&spm=1018.2226.3001.4187



#### byte数据结构

#### 深拷贝、浅拷贝

#### 装饰器

#### pytorch优化器区别

#### python的一些自动化框架包
